C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE PWM
OBJECT MODULE PLACED IN .\Release\Objects\pwm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\pwm.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\pwm.lst) OBJECT(.\Release\Ob
                    -jects\pwm.obj)

line level    source

   1          #include "pwm.h"
   2          #include "time0.h"
   3          
   4          // ç”±æ¸©åº¦é™åˆ¶çš„PWMå ç©ºæ¯” ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   5          volatile u16 limited_pwm_duty_due_to_temp = MAX_PWM_DUTY;
   6          // ç”±äºå‘åŠ¨æœºä¸ç¨³å®šï¼Œè€Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è
             -®¤ä¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   7          volatile u16 limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
   8          // ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰PWMé€šé“éƒ½ç”Ÿæ•ˆï¼Œé»˜è®¤ä
             -¸ºæœ€å¤§å ç©ºæ¯”ï¼‰
   9          volatile u16 limited_pwm_duty_due_to_fan_err = MAX_PWM_DUTY;
  10          
  11          volatile u16 cur_pwm_channel_0_duty;                          // å½“å‰è®¾ç½®çš„ã€ pwm_channle_0 çš„å ç©
             -ºæ¯”ï¼ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  12          volatile u16 expect_adjust_pwm_channel_0_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_0 å
             - ç©ºæ¯”
  13          volatile u16 adjust_pwm_channel_0_duty = MAX_PWM_DUTY;        // pwm_channle_0 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  14          
  15          volatile u16 cur_pwm_channel_1_duty;                          // å½“å‰è®¾ç½®çš„ç¬¬äºŒè·¯PWMçš„å ç©ºæ¯”ï¼
             -ˆåªæœ‰é¥æ§å™¨æŒ‡å®šè¦ä¿®æ”¹å®ƒçš„å€¼æˆ–æ˜¯å®šæ—¶å™¨ç¼“æ…¢è°ƒèŠ‚ï¼Œæ‰ä¼šè¢«ä¿®æ”¹ï¼‰
  16          volatile u16 expect_adjust_pwm_channel_1_duty = MAX_PWM_DUTY; // å­˜æ”¾æœŸæœ›è°ƒèŠ‚åˆ°çš„ pwm_channle_1 å
             - ç©ºæ¯”
  17          volatile u16 adjust_pwm_channel_1_duty = MAX_PWM_DUTY;        // pwm_channle_1 è¦è°ƒæ•´åˆ°çš„å ç©ºæ¯”
  18          
  19          #define STMR0_PEROID_VAL (SYSCLK / 8000 - 1)
  20          #define STMR1_PEROID_VAL (SYSCLK / 8000 - 1)
  21          void pwm_init(void)
  22          {
  23   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); // æ¸…ç©ºè®¡æ•°å€¼
  24   1      
  25   1          STMR0_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
  26   1          STMR0_PRH = STMR_PRD_VAL_H((STMR0_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  27   1          STMR0_PRL = STMR_PRD_VAL_L((STMR0_PEROID_VAL >> 0) & 0xFF);
  28   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  29   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  30   1          STMR_PWMVALA |= STMR_0_PWMVALA(0x1);
  31   1      
  32   1          STMR_CNTMD |= STMR_0_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  33   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  34   1          STMR_CNTCLR |= STMR_0_CNT_CLR(0x1); //
  35   1          STMR_CNTEN |= STMR_0_CNT_EN(0x1);   // ä½¿èƒ½
  36   1          STMR_PWMEN |= STMR_0_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  37   1      
  38   1          P1_MD1 &= ~GPIO_P16_MODE_SEL(0x03); // P16 14è„š
  39   1          P1_MD1 |= GPIO_P16_MODE_SEL(0x01);
  40   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03); // P14 16è„š
  41   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  42   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;      // AFåŠŸèƒ½è¾“å‡º
  43   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
  44   1      
  45   1          // P15 15è„š ä½œä¸ºç¬¬2è·¯PWMè¾“å‡º
  46   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1);                         // æ¸…ç©ºè®¡æ•°å€¼
  47   1          STMR1_PSC = STMR_PRESCALE_VAL(0x07);                        // é¢„åˆ†é¢‘
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 2   

  48   1          STMR1_PRH = STMR_PRD_VAL_H((STMR1_PEROID_VAL >> 8) & 0xFF); // å‘¨æœŸå€¼
  49   1          STMR1_PRL = STMR_PRD_VAL_L((STMR1_PEROID_VAL >> 0) & 0xFF);
  50   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((0) >> 8) & 0xFF); // æ¯”è¾ƒå€¼ (æ¸…ç©ºæ¯”è¾ƒå€¼)
  51   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((0) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  52   1          STMR_PWMVALA |= STMR_1_PWMVALA(0x1);              // STMR1 PWMè¾“å‡ºå€¼ ( 0x1:è®¡æ•°CNTå¤§äºç­‰äºæ¯”
             -è¾ƒå€¼A,PWMè¾“å‡º1,å°äºè¾“å‡º0 )
  53   1      
  54   1          STMR_CNTMD |= STMR_1_CNT_MODE(0x1); // è¿ç»­è®¡æ•°æ¨¡å¼
  55   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1); // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  56   1          STMR_CNTCLR |= STMR_1_CNT_CLR(0x1); //
  57   1          STMR_CNTEN |= STMR_1_CNT_EN(0x1);   // ä½¿èƒ½
  58   1          STMR_PWMEN |= STMR_1_PWM_EN(0x1);   // PWMè¾“å‡ºä½¿èƒ½
  59   1      
  60   1      #if USE_MY_TEST_PIN
                  P0_MD1 &= ~GPIO_P05_MODE_SEL(0x03); // ç”¨å¼€å‘æ¿ä¸Šçš„ p05
                  P0_MD1 |= GPIO_P05_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
              #else
  65   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03); // P15 15è„š
  66   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);  // è¾“å‡ºæ¨¡å¼
  67   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT;  // é€‰æ‹©stmr1_pwmout
  68   1      #endif //  #if USE_MY_TEST_PIN
  69   1      }
  70          
  71          // è®¾ç½®é€šé“0çš„å ç©ºæ¯”
  72          void set_pwm_channel_0_duty(u16 channel_duty)
  73          {
  74   1          STMR0_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  75   1          STMR0_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  76   1          STMR_LOADEN |= STMR_0_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  77   1      }
  78          
  79          // è®¾ç½®é€šé“1çš„å ç©ºæ¯”
  80          void set_pwm_channel_1_duty(u16 channel_duty)
  81          {
  82   1          STMR1_CMPAH = STMR_CMPA_VAL_H(((channel_duty) >> 8) & 0xFF); // æ¯”è¾ƒå€¼
  83   1          STMR1_CMPAL = STMR_CMPA_VAL_L(((channel_duty) >> 0) & 0xFF); // æ¯”è¾ƒå€¼
  84   1          STMR_LOADEN |= STMR_1_LOAD_EN(0x1);                          // è‡ªåŠ¨è£…è½½ä½¿èƒ½
  85   1      }
  86          
  87          /*
  88              æ»¤æ³¢ã€åˆ¤æ–­ç”µå‹æ˜¯å¦æœ‰è·³åŠ¨ï¼Œä¸€æ®µæ—¶é—´å†…ç”µå‹æµ®åŠ¨è¿‡å¤§ï¼Œ
  89              æ‰€ä½¿ç”¨åˆ°çš„è¿™äº›å˜é‡
  90          */
  91          static u16 t_count = 0;
  92          static u16 t_adc_max = 0;    // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å¤§adå€¼
  93          static u16 t_adc_min = 4096; // å­˜æ”¾ä¸€æ®µæ—¶é—´å†…é‡‡é›†åˆ°çš„æœ€å°adå€¼
  94          static u8 over_drive_status = 0;
  95          #define OVER_DRIVE_RESTART_TIME (30)
  96          
  97          static volatile u16 filter_buff_2[270] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ (å¯¹åº” 5.83ms æ‰§è¡Œä¸€æ¬¡çš„å‡½æ•
             -° according_pin9_to_adjust_pwm )
  98          // static volatile u16 filter_buff_2[540] = {0}; // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ (å¯¹åº” 2.93ms æ‰§è¡Œä¸€æ¬¡çš„å‡
             -½æ•° according_pin9_to_adjust_pwmï¼Œæ—¶é—´è¶ŠçŸ­ï¼Œæ•°ç»„éœ€è¦åŠ å¤§)
  99          static volatile u16 buff_index_2 = 0;         // ç”¨äºæ»¤æ³¢çš„æ•°ç»„ä¸‹æ ‡
 100          
 101          /*
 102              ç”µæºç”µå‹ä½äº170V-AC,å¯åŠ¨ä½å‹ä¿æŠ¤ï¼Œç”µæºç”µå‹é«˜äº170V-ACï¼Œå…³é—­ä½å‹ä¿æŠ¤
 103              æ¸©åº¦æ­£å¸¸ï¼Œæ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ
 104              æ³¨æ„ï¼Œæ¯æ¬¡è°ƒç”¨åˆ°è¯¥å‡½æ•°ï¼Œåº”è¯¥åœ¨5.75mså·¦å³ï¼Œæ£€æµ‹å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®šçš„åŸç†æ˜¯
             -æ£€æµ‹é¢‘ç‡ï¼Œ
 105              å¦‚æœä¸åœ¨5.75msé™„è¿‘ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ£€æµ‹ä¸å‡†ç¡®ï¼Œæ£€æµ‹ä¸åˆ°å‘åŠ¨æœºåŠŸç‡ä¸ç¨³å®š
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 3   

 106          */
 107          void according_pin9_to_adjust_pwm(void)
 108          {
 109   1          // static u16 last_limited_pwm_duty_due_to_unstable_engine = MAX_PWM_DUTY;
 110   1      
 111   1      #define ADC_DEAD_ZONE_NEAR_170VAC (30) // 170VACé™„è¿‘çš„adå€¼æ­»åŒº
 112   1          static volatile u16 filter_buff[32] = {
 113   1              0xFFFF,
 114   1          };
 115   1          static volatile u8 buff_index = 0;
 116   1          static volatile u8 flag_is_sub_power = 0;  // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡ï¼ˆçŠ¶æ€æœºï¼‰
 117   1          static volatile u8 flag_is_sub_power2 = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å‡åŠŸç‡
 118   1          static volatile bit flag_is_add_power = 0; // æ ‡å¿—ä½ï¼Œæ˜¯å¦è¦è¿ç»­å¢åŠŸç‡
 119   1      
 120   1          volatile u32 adc_pin_9_avg = 0; // å­˜æ”¾å¹³å‡å€¼
 121   1      
 122   1          if (filter_buff[0] == 0xFFFF) // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ£€æµ‹ï¼Œè®©æ•°ç»„å†…æ‰€æœ‰å…ƒç´ éƒ½å˜ä¸ºç¬¬ä¸€æ¬¡
             -é‡‡é›†çš„æ•°æ®ï¼Œæ–¹ä¾¿å¿«é€Ÿä½œå‡ºå˜åŒ–
 123   1          {
 124   2              u16 i = 0;
 125   2              for (; i < ARRAY_SIZE(filter_buff); i++)
 126   2              {
 127   3                  filter_buff[i] = adc_val_pin_9;
 128   3              }
 129   2      
 130   2              // for (i = 0; i < 270; i++)
 131   2              // for (i = 0; i < 540; i++)
 132   2              for (i = 0; i < ARRAY_SIZE(filter_buff_2); i++)
 133   2              {
 134   3                  filter_buff_2[i] = adc_val_pin_9;
 135   3              }
 136   2          }
 137   1          else
 138   1          {
 139   2              u16 temp = filter_buff[buff_index];
 140   2              temp += adc_val_pin_9;
 141   2              temp >>= 1;
 142   2              filter_buff[buff_index] = temp;
 143   2              buff_index++;
 144   2              if (buff_index >= ARRAY_SIZE(filter_buff))
 145   2              {
 146   3                  buff_index = 0;
 147   3              }
 148   2          }
 149   1      
 150   1          { // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 151   2              u16 i = 0;
 152   2              for (; i < ARRAY_SIZE(filter_buff); i++)
 153   2              {
 154   3                  adc_pin_9_avg += filter_buff[i];
 155   3              }
 156   2      
 157   2              // adc_pin_9_avg /= ARRAY_SIZE(filter_buff);
 158   2              adc_pin_9_avg >>= 5;
 159   2          } // å–å‡ºæ•°ç»„å†…çš„æ•°æ®ï¼Œè®¡ç®—å¹³å‡å€¼
 160   1      
 161   1          // åœ¨å‰é¢æ»¤æ³¢çš„åŸºç¡€ä¸Šå†è¿›è¡Œä¸€æ¬¡æ»¤æ³¢
 162   1          filter_buff_2[buff_index_2] = adc_pin_9_avg;
 163   1          buff_index_2++;
 164   1          // if (buff_index_2 >= 270)
 165   1          // if (buff_index_2 >= 540)
 166   1          if (buff_index_2 >= ARRAY_SIZE(filter_buff_2))
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 4   

 167   1          {
 168   2              buff_index_2 = 0;
 169   2          }
 170   1      
 171   1      #if USE_MY_DEBUG
                  // printf(",b=%lu,", adc_pin_9_avg);
              #endif
 174   1      
 175   1          {
 176   2              u16 i = 0;
 177   2              t_adc_max = 0;
 178   2              t_adc_min = 4096;
 179   2              // for (; i < 270; i++)
 180   2              // for (; i < 540; i++)
 181   2              for (; i < ARRAY_SIZE(filter_buff_2); i++)
 182   2              {
 183   3                  if (filter_buff_2[i] > t_adc_max)
 184   3                      t_adc_max = filter_buff_2[i];
 185   3                  if (filter_buff_2[i] < t_adc_min)
 186   3                      t_adc_min = filter_buff_2[i];
 187   3                  if ((t_adc_max - t_adc_min) > 80)
 188   3                  { // ç”µå‹æ³¢åŠ¨
 189   4                      over_drive_status = OVER_DRIVE_RESTART_TIME;
 190   4                  }
 191   3                  else
 192   3                  {
 193   4                      if (over_drive_status)
 194   4                          over_drive_status--;
 195   4                  }
 196   3              }
 197   2      
 198   2              // MY_DEBUG:
 199   2              // { 
 200   2              //     // æ ¹æ®å‘åŠ¨æœºä¸ç¨³å®šé™åŠŸç‡çš„åŠŸèƒ½æ­£å¸¸æ—¶ï¼Œæµ‹å¾—æ˜¯5.83msæ‰§è¡Œä¸€æ¬¡ï¼Œæ¯1
             -00æ¬¡æ‰“å°ä¸€æ¬¡ï¼Œå¹³å‡è€—æ—¶æ˜¯583ms
 201   2              //     // å¦‚æœå¾ªç¯å¤§äº5.83msï¼Œåœ¨å®¢æˆ·é‚£é‡Œæµ‹è¯•å¥½åƒåŠŸèƒ½ä¹Ÿæ­£å¸¸ï¼Œå®¢æˆ·æ²¡æœ‰è¿›ä
             -¸€æ­¥åé¦ˆ
 202   2              //     static u8 cnt = 0;
 203   2              //     cnt++;
 204   2              //     if (cnt >= 100)
 205   2              //     {
 206   2              //         cnt = 0;
 207   2              //         printf("__LINE__ %u\n", __LINE__);
 208   2              //     }
 209   2              // }
 210   2          }
 211   1      
 212   1          if (adc_pin_9_avg >= (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC) || (flag_is_add_power && adc_pin_9_av
             -g > (1645 /*1475*/ + ADC_DEAD_ZONE_NEAR_170VAC))) // å¤§äº 170VAC
 213   1          {
 214   2              // å¤§äº170VACï¼Œæ¢å¤100%å ç©ºæ¯”ï¼Œä½†æ˜¯ä¼˜å…ˆçº§æ¯” "9è„šç”µå‹æ£€æµ‹åˆ°å‘é€æœºåŠŸç‡ä¸ç
             -¨³å®šï¼Œè¿›è€Œé™åŠŸç‡" ä½
 215   2              flag_is_sub_power = 0;
 216   2              flag_is_sub_power2 = 0;
 217   2              flag_is_add_power = 1;
 218   2      
 219   2              if (over_drive_status == OVER_DRIVE_RESTART_TIME) // 9è„šç”µå‹è¶…è¿‡ä¸ç¨³å®šé˜ˆå€¼å¯¹åº”çš„ç”µå
             -‹
 220   2              {
 221   3                  over_drive_status -= 1;
 222   3                  // if (adjust_duty > PWM_DUTY_50_PERCENT)
 223   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_50_PERCENT)
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 5   

 224   3                  {
 225   4                      // adjust_duty -= 300; // å˜åŒ–å¤ªå¤§ï¼Œä¼šé€ æˆç¯å…‰é—ªçƒ
 226   4                      // adjust_duty -= 1;
 227   4                      limited_pwm_duty_due_to_unstable_engine -= 1;
 228   4                  }
 229   3      
 230   3                  // if (adjust_duty < PWM_DUTY_50_PERCENT)
 231   3                  if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_50_PERCENT)
 232   3                  {
 233   4                      // adjust_duty = PWM_DUTY_50_PERCENT;
 234   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_50_PERCENT;
 235   4                  }
 236   3              }
 237   2              else if (over_drive_status == 0)
 238   2              {
 239   3                  // æœªæ»¡è½½ pwm++
 240   3                  if (flag_is_pwm_add_time_comes) // pwmå ç©ºæ¯”é€’å¢æ—¶é—´åˆ°æ¥
 241   3                  {
 242   4                      flag_is_pwm_add_time_comes = 0;
 243   4                      // if (adjust_duty < PWM_DUTY_100_PERCENT)
 244   4                      if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_100_PERCENT)
 245   4                      {
 246   5                          // adjust_duty++;
 247   5                          limited_pwm_duty_due_to_unstable_engine++;
 248   5                      }
 249   4                  }
 250   3              }
 251   2          }
 252   1          else if (adc_pin_9_avg > (1475) && (adc_pin_9_avg <= (1645 /*1475*/) || flag_is_sub_power == 4)) // å°
             -äº 170VAC
 253   1          {
 254   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 255   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 256   2              {
 257   3                  flag_is_pwm_sub_time_comes = 0;
 258   3                  // if (flag_is_sub_power == 0)
 259   3                  //     flag_is_sub_power = 1;
 260   3                  // else if (flag_is_sub_power == 1)
 261   3                  //     flag_is_sub_power = 2;
 262   3                  if (flag_is_sub_power < 4)
 263   3                      flag_is_sub_power++;
 264   3      
 265   3                  flag_is_sub_power2 = 0;
 266   3                  flag_is_add_power = 0;
 267   3      
 268   3                  // if (adjust_duty > PWM_DUTY_30_PERCENT)
 269   3                  // if (adjust_duty > PWM_DUTY_50_PERCENT)
 270   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_50_PERCENT)
 271   3                  {
 272   4                      // adjust_duty -= 2;
 273   4                      limited_pwm_duty_due_to_unstable_engine -= 2;
 274   4                  }
 275   3                  // else if (adjust_duty < PWM_DUTY_50_PERCENT)
 276   3                  else if (limited_pwm_duty_due_to_unstable_engine < PWM_DUTY_50_PERCENT)
 277   3                  {
 278   4                      // adjust_duty++;
 279   4                      limited_pwm_duty_due_to_unstable_engine++;
 280   4                  }
 281   3                  else
 282   3                  {
 283   4                      // adjust_duty = PWM_DUTY_50_PERCENT;
 284   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_50_PERCENT;
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 6   

 285   4                  }
 286   3              }
 287   2          }
 288   1          else if (adc_pin_9_avg <= (1475) || (flag_is_sub_power2)) // å°äº 170VAC
 289   1          {
 290   2              // é”å®šæœ€å¤§çš„å ç©ºæ¯”ä¸º50%ï¼Œå¹¶ä¸”ç»™ç›¸åº”æ ‡å¿—ä½ç½®ä¸€
 291   2              if (flag_is_pwm_sub_time_comes) // pwmå ç©ºæ¯”é€’å‡æ—¶é—´åˆ°æ¥
 292   2              {
 293   3                  flag_is_pwm_sub_time_comes = 0;
 294   3                  // if (flag_is_sub_power2 < 4)
 295   3                  //     flag_is_sub_power2++;
 296   3      
 297   3                  flag_is_sub_power2 = 1;
 298   3                  flag_is_sub_power = 0;
 299   3                  flag_is_add_power = 0;
 300   3      
 301   3                  // if (adjust_duty > PWM_DUTY_50_PERCENT)
 302   3                  // if (adjust_duty > PWM_DUTY_30_PERCENT)
 303   3                  if (limited_pwm_duty_due_to_unstable_engine > PWM_DUTY_30_PERCENT)
 304   3                  {
 305   4                      // adjust_duty -= 2;
 306   4                      limited_pwm_duty_due_to_unstable_engine -= 2;
 307   4                  }
 308   3                  else
 309   3                  {
 310   4                      // adjust_duty = PWM_DUTY_50_PERCENT;
 311   4                      // adjust_duty = PWM_DUTY_30_PERCENT;
 312   4                      limited_pwm_duty_due_to_unstable_engine = PWM_DUTY_30_PERCENT;
 313   4                  }
 314   3              }
 315   2          }
 316   1      
 317   1          // å¦‚æœ limited_pwm_duty_due_to_unstable_engine æ”¹å˜ï¼Œè¿™é‡Œè¦æ›´æ–° adjust_pwm_channel_ x _duty
             - çš„çŠ¶æ€
 318   1          // if (last_limited_pwm_duty_due_to_unstable_engine != limited_pwm_duty_due_to_unstable_engine)
 319   1          // {
 320   1          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_0_duty);
 321   1          //     adjust_pwm_channel_1_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_channel_1_duty);
 322   1          //     last_limited_pwm_duty_due_to_unstable_engine = limited_pwm_duty_due_to_unstable_engine;
 323   1          // }
 324   1      }
 325          
 326          // æ ¹æ®9è„šçš„ç”µå‹æ¥è®¾å®š16è„šçš„ç”µå¹³ï¼ˆè¿‡å‹ä¿æŠ¤ï¼‰
 327          void according_pin9_to_adjust_pin16(void)
 328          {
 329   1          // å½“9è„šç”µå‹é«˜äº 3.6 Væ—¶ï¼Œ16è„šè¾“å‡º1KHz é«˜ç”µå¹³,ç”¨äºæ§åˆ¶Q2çš„å¯¼é€šï¼ˆç”¨äºå…³æœºï¼‰ã
             -€‚
 330   1          // if (adc_val_pin_9 >= 3511)
 331   1          // {
 332   1          //     P14 = 1;
 333   1          // }
 334   1          // else if (adc_val_pin_9 <= 3511 - 40)
 335   1          {
 336   2              P14 = 0;
 337   2          }
 338   1      }
 339          
 340          /**
 341           * @brief è·å–ç¬¬ä¸€è·¯PWMçš„è¿è¡ŒçŠ¶æ€
 342           *
 343           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 344           */
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 7   

 345          u8 get_pwm_channel_0_status(void)
 346          {
 347   1          if (STMR_PWMEN & 0x01) // å¦‚æœpwm0ä½¿èƒ½
 348   1          {
 349   2              return 1;
 350   2          }
 351   1          else // å¦‚æœpwm0æœªä½¿èƒ½
 352   1          {
 353   2              return 0;
 354   2          }
 355   1      }
 356          
 357          /**
 358           * @brief è·å–ç¬¬äºŒè·¯PWMçš„è¿è¡ŒçŠ¶æ€
 359           *
 360           * @return u8 0--pwmå…³é—­ï¼Œ1--pwmå¼€å¯
 361           */
 362          u8 get_pwm_channel_1_status(void)
 363          {
 364   1          if (STMR_PWMEN & (0x01 << 1)) // å¦‚æœpwm1ä½¿èƒ½
 365   1          {
 366   2              return 1;
 367   2          }
 368   1          else // å¦‚æœ pwm æœªä½¿èƒ½
 369   1          {
 370   2              return 0;
 371   2          }
 372   1      }
 373          
 374          void pwm_channel_0_enable(void)
 375          {
 376   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 377   1          STMR_PWMEN |= 0x01;                // ä½¿èƒ½PWM0çš„è¾“å‡º
 378   1          FOUT_S16 = GPIO_FOUT_STMR0_PWMOUT; // stmr0_pwmout
 379   1      }
 380          
 381          void pwm_channel_0_disable(void)
 382          {
 383   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 384   1          STMR_PWMEN &= ~0x01;          // ä¸ä½¿èƒ½PWM0çš„è¾“å‡º
 385   1          FOUT_S16 = GPIO_FOUT_AF_FUNC; //
 386   1          P16 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 387   1      }
 388          
 389          void pwm_channel_1_enable(void)
 390          {
 391   1          // è¦å…ˆä½¿èƒ½PWMè¾“å‡ºï¼Œåœ¨é…ç½®IOï¼Œå¦åˆ™åœ¨é€»è¾‘åˆ†æä»ªä¸Šçœ‹ä¼šæœ‰ä¸ªç¼ºå£
 392   1          STMR_PWMEN |= 0x01 << 1; // ä½¿èƒ½PWM1çš„è¾“å‡º
 393   1      
 394   1      #if USE_MY_TEST_PIN
                  FOUT_S05 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
              #else
 397   1          FOUT_S15 = GPIO_FOUT_STMR1_PWMOUT; // stmr1_pwmout
 398   1      #endif
 399   1      }
 400          
 401          void pwm_channel_1_disable(void)
 402          {
 403   1          // ç›´æ¥è¾“å‡º0%çš„å ç©ºæ¯”ï¼Œå¯èƒ½ä¼šæœ‰äº›è·³åŠ¨ï¼Œéœ€è¦å°†å¯¹åº”çš„å¼•è„šé…ç½®å›è¾“å‡ºæ¨¡å¼
 404   1          STMR_PWMEN &= ~(0x01 << 1); // ä¸ä½¿èƒ½PWM1çš„è¾“å‡º
 405   1      
 406   1      #if USE_MY_TEST_PIN
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 8   

                  FOUT_S05 = GPIO_FOUT_AF_FUNC; //;
                  P05 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
              #else
 410   1          FOUT_S15 = GPIO_FOUT_AF_FUNC; //
 411   1          P15 = 1;                      // é«˜ç”µå¹³ä¸ºå…³ç¯
 412   1      #endif
 413   1      }
 414          
 415          /**
 416           * @brief æ ¹æ®ä¼ å‚ï¼ŒåŠ ä¸Šçº¿æ§è°ƒå…‰çš„é™åˆ¶ã€æ¸©åº¦è¿‡çƒ­é™åˆ¶ã€é£æ‰‡å·¥ä½œå¼‚å¸¸é™åˆ¶ï¼Œ
 417           *          è®¡ç®—æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼ˆå¯¹æ‰€æœ‰pwmé€šé“éƒ½æœ‰æ•ˆï¼‰
 418           *
 419           * @attention å¦‚æœåå¤è°ƒç”¨ adjust_pwm_channel_x_duty = get_pwm_channel_x_adjust_duty(adjust_pwm_chan
             -nel_x_duty);
 420           *              ä¼šå¯¼è‡´ adjust_pwm_channel_x_duty è¶Šæ¥è¶Šå°
 421           *
 422           * @param pwm_adjust_duty ä¼ å…¥çš„ç›®æ ‡å ç©ºæ¯”ï¼ˆéæœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”ï¼‰ expect_adjust_pwm_chan
             -nel_x_duty 
 423           *
 424           * @return u16 æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 425           */
 426          u16 get_pwm_channel_x_adjust_duty(u16 pwm_adjust_duty)
 427          {
 428   1          // å­˜æ”¾å‡½æ•°çš„è¿”å›å€¼ -- æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 429   1          // æ ¹æ®è®¾å®šçš„ç›®æ ‡å ç©ºæ¯”ï¼Œæ›´æ–°ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„ç›®æ ‡å ç©ºæ¯”ï¼š
 430   1          u16 tmp_pwm_duty = (u32)pwm_adjust_duty * limited_max_pwm_duty / MAX_PWM_DUTY; // pwm_adjust_duty * æ—
             -‹é’®é™åˆ¶çš„å ç©ºæ¯”ç³»æ•°
 431   1      
 432   1          // æ¸©åº¦ã€å‘åŠ¨æœºå¼‚å¸¸åŠŸç‡ä¸ç¨³å®šã€é£æ‰‡å¼‚å¸¸ï¼Œéƒ½æ˜¯å¼ºåˆ¶é™å®šå ç©ºæ¯”
 433   1      
 434   1          // åˆ¤æ–­ç»è¿‡æ—‹é’®é™åˆ¶ä¹‹åçš„å ç©ºæ¯” ä¼šä¸ä¼š å¤§äº æ¸©åº¦è¿‡çƒ­ä¹‹åé™åˆ¶çš„å ç©ºæ¯”
 435   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_temp)
 436   1          {
 437   2              tmp_pwm_duty = limited_pwm_duty_due_to_temp;
 438   2          }
 439   1      
 440   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºå‘åŠ¨æœºä¸ç¨³å®šè€Œé™åˆ¶çš„ã€å¯ä»¥è°ƒèŠ‚çš„æœ€å¤§å
             - ç©ºæ¯”
 441   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_unstable_engine)
 442   1          {
 443   2              tmp_pwm_duty = limited_pwm_duty_due_to_unstable_engine;
 444   2          }
 445   1      
 446   1          // å¦‚æœé™åˆ¶ä¹‹åçš„å ç©ºæ¯” å¤§äº ç”±äºé£æ‰‡å¼‚å¸¸ï¼Œé™åˆ¶çš„å¯ä»¥è°ƒèŠ‚åˆ°çš„æœ€å¤§å ç©ºæ
             -¯”
 447   1          if (tmp_pwm_duty >= limited_pwm_duty_due_to_fan_err)
 448   1          {
 449   2              tmp_pwm_duty = limited_pwm_duty_due_to_fan_err;
 450   2          }
 451   1      
 452   1          return tmp_pwm_duty; // è¿”å›ç»è¿‡çº¿æ§è°ƒå…‰é™åˆ¶ä¹‹åçš„ã€æœ€ç»ˆçš„ç›®æ ‡å ç©ºæ¯”
 453   1      }
 454          
 455          // æ›´æ–° pwm_channel_0 å¾…è°ƒæ•´çš„å ç©ºæ¯”
 456          // void update_pwm_channel_0_adjust_duty(void)
 457          // {
 458          //     adjust_pwm_channel_0_duty = get_pwm_channel_x_adjust_duty(expect_adjust_pwm_channel_0_duty);
 459          // }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1170    ----
C51 COMPILER V9.60.7.0   PWM                                                               10/16/2025 09:07:20 PAGE 9   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    634       6
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
