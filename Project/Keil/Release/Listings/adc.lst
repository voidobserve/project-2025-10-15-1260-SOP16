C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          volatile u16 adc_val_pin_9 = 0; // å­˜æ”¾9è„šé‡‡é›†åˆ°çš„adå€¼
   8          
   9          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
  10          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
  11          
  12          // volatile bit flag_is_pin_9_vol_bounce = 0; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨
  13          
  14          // adcç›¸å…³çš„å¼•è„šé…ç½®
  15          void adc_pin_config(void)
  16          {
  17   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  18   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  19   1      
  20   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  21   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  22   1      
  23   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  24   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  25   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  26   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  27   1      
  28   1          // P13 -- èŠ¯ç‰‡çš„1è„šï¼Œé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  29   1          P1_PU &= ~(0x01 << 3);             // å…³é—­ä¸Šæ‹‰
  30   1          P1_PD &= ~(0x01 << 3);             // å…³é—­ä¸‹æ‹‰
  31   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x03); // æ¨¡æ‹ŸIOå·¥ä½œæ¨¡å¼
  32   1      }
  33          
  34          // åˆ‡æ¢adcé‡‡é›†çš„å¼•è„šï¼Œé…ç½®å¥½adc
  35          // å‚æ•°å¯ä»¥é€‰æ‹©ï¼š
  36          // ADC_SEL_PIN_GET_TEMP
  37          // ADC_SEL_PIN_GET_VOL
  38          void adc_sel_pin(const u8 adc_sel)
  39          {
  40   1          // åˆ‡æ¢é‡‡é›†å¼•è„šæ—¶ï¼ŒæŠŠä¹‹å‰é‡‡é›†åˆ°çš„adå€¼æ¸…ç©º
  41   1          // adc0_val = 0;
  42   1          static u8 last_adc_sel = 0;
  43   1          if (last_adc_sel == adc_sel)
  44   1          {
  45   2              // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€€å‡
             -º
  46   2              return;
  47   2          }
  48   1      
  49   1          last_adc_sel = adc_sel;
  50   1      
  51   1          ADC_CFG1 |= (0x0F << 3); // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 2   

  52   1          ADC_CFG2 = 0xFF;         // é€šé“0é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
  53   1      
  54   1          switch (adc_sel)
  55   1          {
  56   2          case ADC_SEL_PIN_GET_TEMP: // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹åº”çš„ç”µå‹çš„å¼•è„šï¼ˆ8è„šï¼‰
  57   2      
  58   2              // ADCé…ç½®
  59   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå
             -‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  60   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå
             -‹VCCA
  61   2                           ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  62   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä½¿è
             -ƒ½ä¿¡å·
  63   2                          ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæµè
             -ƒ½ä½¿ä¿¡å·
  64   2                          ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  65   2      
  66   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  67   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  68   2      
  69   2              break;
  70   2      
  71   2          case ADC_SEL_PIN_GET_VOL: // æ£€æµ‹å›è·¯ç”µå‹çš„å¼•è„šï¼ˆ9è„šï¼‰
  72   2      
  73   2              // ADCé…ç½®
  74   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€‰æ‹
             -©çš„å‚è€ƒç”µå‹
  75   2              // ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  76   2              //              ADC_TEN_SEL(0x3);
  77   2              ADC_ACON1 |= ADC_VREF_SEL(0x5) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ‰‹å†Œè¯´æœªæ ¡å‡†)
  78   2                           ADC_TEN_SEL(0x3);     /* å…³é—­æµ‹è¯•ä¿¡å· */
  79   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  80   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  81   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  82   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x17) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
  83   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  84   2      
  85   2              break;
  86   2      
  87   2          case ADC_SEL_PIN_P31: // P31ã€7è„šï¼Œæ£€æµ‹æ—‹é’®è°ƒå…‰
  88   2      
  89   2              // ADCé…ç½®
  90   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  91   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  92   2                           ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  93   2              ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  94   2                          ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  95   2                          ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  96   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
  97   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  98   2      
  99   2              break;
 100   2      
 101   2          case ADC_SEL_PIN_FAN_DETECT: // P13 èŠ¯ç‰‡çš„1è„šï¼Œæ£€æµ‹é£æ‰‡æ˜¯å¦å¼‚å¸¸
 102   2      
 103   2              ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 104   2              ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
 105   2                           ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å·
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 3   

 106   2              ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„CMPä
             -½¿èƒ½ä¿¡å·
 107   2                          ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
 108   2                          ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1x
 109   2      
 110   2              ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
 111   2                         ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 112   2      
 113   2              break;
 114   2          }
 115   1      
 116   1          ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0è½¬æ¢
 117   1                      ADC_EN(0x1);        // ä½¿èƒ½A/Dè½¬æ¢
 118   1          // delay_ms(1);                    // ç­‰å¾…ADCç¨³å®š
 119   1          // å®˜æ–¹çš„demoä¸­æåˆ°ç­‰å¾…20usä»¥ä¸Š
 120   1          delay((u32)1450 / 2);
 121   1      }
 122          
 123          // adcå•æ¬¡é‡‡é›†+è½¬æ¢ï¼ˆæ²¡æœ‰æ»¤æ³¢ï¼‰
 124          u16 adc_get_val_single(void)
 125          {
 126   1          u16 adc_val = 0;
 127   1          ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 128   1          while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 129   1              ;                                            // ç­‰å¾…è½¬æ¢å®Œæˆ
 130   1          adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å–channel0çš„å€¼
 131   1          ADC_STA = ADC_CHAN0_DONE(0x1);                   // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 132   1          return adc_val;
 133   1      }
 134          
 135          // è·å–ä¸€æ¬¡adcé‡‡é›†+æ»¤æ³¢åçš„å€¼
 136          u16 adc_get_val(void)
 137          {
 138   1          u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 139   1          volatile u16 g_temp_value = 0;
 140   1          volatile u32 g_tmpbuff = 0;
 141   1          volatile u16 g_adcmax = 0;
 142   1          volatile u16 g_adcmin = 0xFFFF;
 143   1      
 144   1          // é‡‡é›†20æ¬¡ï¼Œå»æ‰å‰ä¸¤æ¬¡é‡‡æ ·ï¼Œå†å»æ‰ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼Œå†å–å¹³å‡å€¼
 145   1          for (i = 0; i < 20; i++)
 146   1          {
 147   2              ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 148   2              while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 149   2                  ;                                                 // ç­‰å¾…è½¬æ¢å®Œæˆ
 150   2              g_temp_value = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å– channel0 çš„å€¼
 151   2              ADC_STA = ADC_CHAN0_DONE(0x1);                        // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 152   2      
 153   2              if (i < 2)
 154   2                  continue; // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·çš„
 155   2              if (g_temp_value > g_adcmax)
 156   2                  g_adcmax = g_temp_value; // æœ€å¤§
 157   2              if (g_temp_value < g_adcmin)
 158   2                  g_adcmin = g_temp_value; // æœ€å°
 159   2      
 160   2              g_tmpbuff += g_temp_value;
 161   2          }
 162   1      
 163   1          g_tmpbuff -= g_adcmax;           // å»æ‰ä¸€ä¸ªæœ€å¤§
 164   1          g_tmpbuff -= g_adcmin;           // å»æ‰ä¸€ä¸ªæœ€å°
 165   1          g_temp_value = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 4   

 166   1      
 167   1          return g_temp_value;
 168   1      }
 169          
 170          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 171          u32 get_voltage_from_pin(void)
 172          {
 173   1          volatile u32 adc_aver_val = 0; // å­˜æ”¾adcæ»¤æ³¢åçš„å€¼
 174   1          // é‡‡é›†çƒ­æ•ç”µé˜»çš„ç”µå‹
 175   1          // adc_aver_val = adc_get_val();
 176   1          adc_aver_val = adc_get_val_single();
 177   1      
 178   1          // 4095ï¼ˆadcè½¬æ¢åï¼Œå¯èƒ½å‡ºç°çš„æœ€å¤§çš„å€¼ï¼‰ * 0.0012 == 4.914ï¼Œçº¦ç­‰äº5Vï¼ˆVCCï¼‰
 179   1          return adc_aver_val * 12 / 10; // å‡è®¾æ˜¯4095ï¼Œ4095 * 12/10 == 4915mV
 180   1      }
 181          
 182          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 183          void temperature_scan(void)
 184          {
 185   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 186   1      
 187   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 188   1          if (TEMP_75_5_MIN == temp_status)
 189   1          {
 190   2              return;
 191   2          }
 192   1      
 193   1          adc_sel_pin(ADC_SEL_PIN_GET_TEMP); // å…ˆåˆ‡æ¢æˆçƒ­æ•ç”µé˜»å¯¹åº”çš„å¼•è„šçš„adcé…ç½®
 194   1          voltage = get_voltage_from_pin();  // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 195   1      
 196   1          // MY_DEBUG:
 197   1          // voltage = 4095; // æµ‹è¯•ç”¨
 198   1      
 199   1      #if USE_MY_DEBUG
                  // printf("PIN-8 voltage: %lu mV\n", voltage);
              #endif // USE_MY_DEBUG
 202   1      
 203   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 204   1          if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 205   1          {
 206   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 207   2      
 208   2      // æ£€æµ‹10æ¬¡ï¼Œå¦‚æœ10æ¬¡éƒ½å°äºè¿™ä¸ªç”µå‹å€¼ï¼Œæ‰è¯´æ˜æ¸©åº¦çœŸçš„å¤§äº75æ‘„æ°åº¦
 209   2      #if 0 // OLD
              
                      u8 i = 0;
                      for (i = 0; i < 10; i++)
                      {
                          voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
                          if (voltage > VOLTAGE_TEMP_75)
                          {
                              // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
                              temp_status = TEMP_NORMAL;
                              return;
                          }
                      }
              
                      // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜æ¸©åº¦ç¡®å®å¤§äº75æ‘„æ°åº¦
              
              #if USE_MY_DEBUG
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 5   

              // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦\n");
              // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV", voltage);
              #endif
              
                      temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦
                      return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
              
              #endif // OLD
 234   2      
 235   2      #if 1 // NEW
 236   2      
 237   2              static volatile u8 cnt = 0;
 238   2              if (voltage > VOLTAGE_TEMP_75)
 239   2              {
 240   3                  cnt++;
 241   3              }
 242   2              else
 243   2              {
 244   3                  cnt = 0;
 245   3              }
 246   2      
 247   2              if (cnt >= 10)
 248   2              {
 249   3                  cnt = 0;
 250   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦
 251   3              }
 252   2              else
 253   2              {
 254   3                  temp_status = TEMP_NORMAL;
 255   3              }
 256   2      
 257   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 258   2      
 259   2      #endif // NEW
 260   2          }
 261   1          else if (temp_status == TEMP_75)
 262   1          {
 263   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 264   2              static bit tmr1_is_open = 0;
 265   2      
 266   2              if (0 == tmr1_is_open)
 267   2              {
 268   3                  tmr1_is_open = 1;
 269   3                  tmr1_cnt = 0;
 270   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡30min
 271   3              }
 272   2      
 273   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 274   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 275   2              {
 276   3      
 277   3      #if 0 // OLD            
                          u8 i = 0;
              #if USE_MY_DEBUG
                          // printf("æ¸©åº¦è¶…è¿‡äº†75æ‘„æ°åº¦ä¸”è¶…è¿‡äº†30min\n");
                          // printf("æ­¤æ—¶é‡‡é›†åˆ°çš„ç”µå‹å€¼ï¼š%lu mV\n", voltage);
              #endif
              
                          for (i = 0; i < 10; i++)
                          {
                              voltage = get_voltage_from_pin(); // é‡‡é›†çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
                              if (voltage > VOLTAGE_TEMP_75)
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 6   

                              {
                                  // åªè¦æœ‰ä¸€æ¬¡æ¸©åº¦å°äº75æ‘„æ°åº¦ï¼Œå°±è®¤ä¸ºæ¸©åº¦æ²¡æœ‰å¤§äº75æ‘„æ°åº¦
                                  temp_status = TEMP_75;
                                  return;
                              }
                          }
              
                          // å¦‚æœè¿è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜ä¸Šé¢è¿ç»­ã€å¤šæ¬¡æ£€æµ‹åˆ°çš„æ¸©åº¦éƒ½å¤§äº75æ‘„æ°åº¦ 
                          temp_status = TEMP_75_5_MIN;
                          tmr1_disable(); // å…³é—­å®šæ—¶å™¨
                          tmr1_cnt = 0;   // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
                          tmr1_is_open = 0;
                          return;
              #endif // OLD
 302   3      
 303   3      #if 1 // NEW
 304   3      
 305   3                  static volatile u8 cnt = 0;
 306   3      
 307   3                  if (voltage > VOLTAGE_TEMP_75)
 308   3                  {
 309   4                      cnt++;
 310   4                  }
 311   3                  else
 312   3                  {
 313   4                      cnt = 0;
 314   4                  }
 315   3      
 316   3                  if (cnt >= 10)
 317   3                  {
 318   4                      cnt = 0;
 319   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 320   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 321   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 322   4                      tmr1_is_open = 0;
 323   4                  }
 324   3                  else
 325   3                  {
 326   4                      temp_status = TEMP_75;
 327   4                  }
 328   3      
 329   3                  return;
 330   3      #endif // NEW
 331   3              }
 332   2          }
 333   1      }
 334          
 335          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 336          void set_duty(void)
 337          {
 338   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 339   1          if (TEMP_NORMAL == temp_status)
 340   1          {
 341   2              according_pin9_to_adjust_pwm();
 342   2      #if USE_MY_DEBUG
                      // printf("cur duty: %d\n", c_duty);
              #endif
 345   2          }
 346   1          else if (TEMP_75 == temp_status)
 347   1          {
 348   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 7   

 349   2          }
 350   1          // else if (TEMP_75_30MIN == temp_status)
 351   1          else if (TEMP_75_5_MIN == temp_status)
 352   1          {
 353   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 354   2          }
 355   1      }
 356          
 357          // volatile u16 adc_val_pin_9_filter_count = 0;
 358          // u16 adc_val_pin_9_temp;
 359          // æ›´æ–°9è„šé‡‡é›†çš„adå€¼
 360          void adc_update_pin_9_adc_val(void)
 361          {
 362   1          adc_sel_pin(ADC_SEL_PIN_GET_VOL);
 363   1          adc_val_pin_9 = adc_get_val();
 364   1      
 365   1      #if USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
                  // printf("adc_val_pin_9 %u\n", adc_val_pin_9);
              
                  // printf(",a=%u,", adc_val_pin_9);
              #endif // USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 370   1      }
 371          
 372          void fan_scan(void)
 373          {
 374   1          u16 adc_val = 0;
 375   1          adc_sel_pin(ADC_SEL_PIN_FAN_DETECT);
 376   1          // adc_val = adc_get_val();
 377   1          adc_val = adc_get_val_single();
 378   1      
 379   1          // {
 380   1          //     static u16 cnt = 0;
 381   1          //     cnt++;
 382   1          //     if (cnt >= 200)
 383   1          //     {
 384   1          //         cnt = 0;
 385   1          //         printf("fan adc val : %u\n", adc_val);
 386   1          //     }
 387   1          // }
 388   1      
 389   1          /*
 390   1              1è„šç”µå‹ä½äº4.3Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º25%å ç©ºæ¯”ï¼Œ
 391   1              1è„šç”µå‹é«˜äº4.5Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º100%å ç©ºæ¯”
 392   1          */
 393   1      
 394   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 395   1          {
 396   2              if (adc_val <= ADC_VAL_WHEN_FAN_ERR)
 397   2              {
 398   3                  flag_tim_scan_fan_is_err = 1; // è¡¨ç¤ºé£æ‰‡å¼‚å¸¸ï¼Œè®©å®šæ—¶å™¨ç´¯è®¡æ—¶é—´
 399   3              }
 400   2              else
 401   2              {
 402   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 403   3                  flag_tim_scan_fan_is_err = 0;
 404   3              }
 405   2      
 406   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 407   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 408   2          }
C51 COMPILER V9.60.7.0   ADC                                                               10/16/2025 09:07:20 PAGE 8   

 409   1          else // FAN_STATUS_ERROR == cur_fan_status
 410   1          {
 411   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 412   2              if (adc_val >= ADC_VAL_WHEN_FAN_NORMAL)
 413   2              {
 414   3                  flag_tim_scan_fan_is_err = 0; // è¡¨ç¤ºé£æ‰‡æ­£å¸¸
 415   3              }
 416   2      
 417   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 418   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 419   2          }
 420   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    857    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      7      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
