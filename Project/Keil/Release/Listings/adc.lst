C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Release\Objects\adc.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\adc.c LARGE OPTIMIZE(9,SIZE) BROWSE INTVECTOR(0X000C) INCDIR(
                    -..\..\Libraries\Include;..\..\User) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\adc.lst) OBJECT(.\Release\Ob
                    -jects\adc.obj)

line level    source

   1          #include "adc.h"
   2          #include "my_config.h"
   3          
   4          // å­˜æ”¾æ¸©åº¦çŠ¶æ€çš„å˜é‡
   5          volatile u8 temp_status = TEMP_NORMAL;
   6          
   7          volatile u16 adc_val_from_engine; // å­˜æ”¾ ä»å‘åŠ¨æœºä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   8          volatile u16 adc_val_from_knob;   // å­˜æ”¾ ä»æ—‹é’®ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
   9          volatile u16 adc_val_from_temp;   // å­˜æ”¾ ä»çƒ­æ•ç”µé˜»ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  10          volatile u16 adc_val_from_fan;    // å­˜æ”¾ æ£€æµ‹é£æ‰‡ä¸€ä¾§ é‡‡é›†åˆ°çš„adå€¼
  11          
  12          volatile bit flag_tim_scan_fan_is_err = 0;      // æ ‡å¿—ä½ï¼Œç”±å®šæ—¶å™¨æ‰«æå¹¶ç´¯è®¡æ—¶é—´ï¼Œè¡¨ç¤ºå
             -½“å‰é£æ‰‡æ˜¯å¦å¼‚å¸¸
  13          volatile u8 cur_fan_status = FAN_STATUS_NORMAL; // å½“å‰é£æ‰‡çŠ¶æ€
  14          
  15          volatile u8 cur_adc2_status = ADC2_STATUS_NONE; // çŠ¶æ€æœºï¼Œè¡¨ç¤ºå½“å‰adc2çš„çŠ¶æ€
  16          
  17          // volatile bit flag_is_pin_9_vol_bounce = 0; // æ ‡å¿—ä½ï¼Œ9è„šç”µå‹æ˜¯å¦å‘ç”Ÿäº†è·³åŠ¨
  18          
  19          // adcç›¸å…³çš„å¼•è„šé…ç½®
  20          void adc_pin_config(void)
  21          {
  22   1          // P30--8è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  23   1          P3_MD0 |= GPIO_P30_MODE_SEL(0x3);
  24   1      
  25   1          // P27--9è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  26   1          P2_MD1 |= GPIO_P27_MODE_SEL(0x3);
  27   1      
  28   1          // P31--7è„šé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  29   1          P3_PU &= ~(0x01 << 1); // å…³é—­ä¸Šæ‹‰
  30   1          P3_PD &= ~(0x01 << 1); // å…³é—­ä¸‹æ‹‰
  31   1          P3_MD0 |= GPIO_P31_MODE_SEL(0x3);
  32   1      
  33   1          // P13 -- èŠ¯ç‰‡çš„1è„šï¼Œé…ç½®ä¸ºæ¨¡æ‹Ÿè¾“å…¥æ¨¡å¼
  34   1          P1_PU &= ~(0x01 << 3);             // å…³é—­ä¸Šæ‹‰
  35   1          P1_PD &= ~(0x01 << 3);             // å…³é—­ä¸‹æ‹‰
  36   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x03); // æ¨¡æ‹ŸIOå·¥ä½œæ¨¡å¼
  37   1      }
  38          
  39          // åˆ‡æ¢adcé‡‡é›†çš„å¼•è„šï¼Œé…ç½®å¥½adc
  40          // å‚æ•°å¯ä»¥é€‰æ‹©ï¼š
  41          // ADC_SEL_PIN_GET_TEMP
  42          // ADC_SEL_PIN_GET_VOL
  43          // void adc_sel_pin(const u8 adc_sel)
  44          // {
  45          //     // åˆ‡æ¢é‡‡é›†å¼•è„šæ—¶ï¼ŒæŠŠä¹‹å‰é‡‡é›†åˆ°çš„adå€¼æ¸…ç©º
  46          //     // adc0_val = 0;
  47          //     static u8 last_adc_sel = 0;
  48          //     if (last_adc_sel == adc_sel)
  49          //     {
  50          //         // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€
             -€å‡º
  51          //         return;
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 2   

  52          //     }
  53          
  54          //     last_adc_sel = adc_sel;
  55          
  56          //     ADC_CFG1 |= (0x0F << 3); // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
  57          //     ADC_CFG2 = 0xFF;         // é€šé“0é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
  58          
  59          //     switch (adc_sel)
  60          //     {
  61          //     case ADC_SEL_PIN_GET_TEMP: // é‡‡é›†çƒ­æ•ç”µé˜»å¯¹åº”çš„ç”µå‹çš„å¼•è„šï¼ˆ8è„šï¼‰
  62          
  63          //         // ADCé…ç½®
  64          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è€ƒç
             -”µå‹ï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  65          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è€ƒç
             -”µå‹VCCA
  66          //                      ADC_TEN_SEL(0x3);                                           // å…³é—­æµ‹è¯•ä¿¡å·
  67          //         ADC_ACON0 = ADC_CMP_EN(0x1) |                                            // æ‰“å¼€ADCä¸­çš„CMPä
             -½¿èƒ½ä¿¡å·
  68          //                     ADC_BIAS_EN(0x1) |                                           // æ‰“å¼€ADCåç½®ç”µæ
             -µèƒ½ä½¿ä¿¡å·
  69          //                     ADC_BIAS_SEL(0x1);                                           // åç½®ç”µæµï¼š1x
  70          
  71          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x18) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x18--P30ï¼‰
  72          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  73          
  74          //         break;
  75          
  76          //     case ADC_SEL_PIN_GET_VOL: // æ£€æµ‹å›è·¯ç”µå‹çš„å¼•è„šï¼ˆ9è„šï¼‰
  77          
  78          //         // ADCé…ç½®
  79          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ï¼Œæ¸…é™¤é€
             -‰æ‹©çš„å‚è€ƒç”µå‹
  80          //         // ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                         // é€‰æ‹©å†…éƒ¨å‚è
             -€ƒç”µå‹VCCA
  81          //         //              ADC_TEN_SEL(0x3);
  82          //         ADC_ACON1 |= ADC_VREF_SEL(0x5) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹ 4.2V (ç”¨æˆ·æ‰‹å†Œè¯´æœªæ ¡å‡†)
  83          //                      ADC_TEN_SEL(0x3);     /* å…³é—­æµ‹è¯•ä¿¡å· */
  84          //         ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  85          //                     ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
  86          //                     ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
  87          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x17) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
  88          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
  89          
  90          //         break;
  91          
  92          //     case ADC_SEL_PIN_P31: // P31ã€7è„šï¼Œæ£€æµ‹æ—‹é’®è°ƒå…‰
  93          
  94          //         // ADCé…ç½®
  95          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7)); // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹ã€æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
  96          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |   // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA
  97          //                      ADC_TEN_SEL(0x3);     // å…³é—­æµ‹è¯•ä¿¡å·
  98          //         ADC_ACON0 = ADC_CMP_EN(0x1) |      // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
  99          //                     ADC_BIAS_EN(0x1) |     // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 100          //                     ADC_BIAS_SEL(0x1);     // åç½®ç”µæµï¼š1x
 101          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x19) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
 102          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 103          
 104          //         break;
 105          
 106          //     case ADC_SEL_PIN_FAN_DETECT: // P13 èŠ¯ç‰‡çš„1è„šï¼Œæ£€æµ‹é£æ‰‡æ˜¯å¦å¼‚å¸¸
 107          
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 3   

 108          //         ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) | ADC_EXREF_SEL(0x01) | ADC_INREF_SEL(0)); // å…³é—­å¤–éƒ¨å‚è
             -€ƒç”µå‹ï¼Œä¸é€‰æ‹©å¤–éƒ¨å‚è€ƒï¼Œæ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 109          //         ADC_ACON1 |= ADC_VREF_SEL(0x6) |                                            // é€‰æ‹©å†…éƒ¨å‚è
             -€ƒç”µå‹VCCA
 110          //                      ADC_TEN_SEL(0x3);                                              // å…³é—­æµ‹è¯•ä¿¡å
             -·
 111          //         ADC_ACON0 = ADC_CMP_EN(0x1) |                                               // æ‰“å¼€ADCä¸­çš„C
             -MPä½¿èƒ½ä¿¡å·
 112          //                     ADC_BIAS_EN(0x1) |                                              // æ‰“å¼€ADCåç½®ç
             -”µæµèƒ½ä½¿ä¿¡å·
 113          //                     ADC_BIAS_SEL(0x1);                                              // åç½®ç”µæµï¼š1
             -x
 114          
 115          //         ADC_CHS0 = ADC_ANALOG_CHAN(0x0B) | // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x0B--P13ï¼‰
 116          //                    ADC_EXT_SEL(0x0);       // é€‰æ‹©å¤–éƒ¨é€šé“
 117          
 118          //         break;
 119          //     }
 120          
 121          //     ADC_CFG0 |= ADC_CHAN0_EN(0x1) | // ä½¿èƒ½é€šé“0è½¬æ¢
 122          //                 ADC_EN(0x1);        // ä½¿èƒ½A/Dè½¬æ¢
 123          //     // delay_ms(1);                    // ç­‰å¾…ADCç¨³å®š
 124          //     // å®˜æ–¹çš„demoä¸­æåˆ°ç­‰å¾…20usä»¥ä¸Š
 125          //     delay((u32)1450 / 2);
 126          //     // delay((u32)1450 / 4);
 127          // }
 128          
 129          void adc_config(void)
 130          {
 131   1          __EnableIRQ(ADC_IRQn); // ä½¿èƒ½ADCä¸­æ–­
 132   1          IE_EA = 1;             // ä½¿èƒ½æ€»ä¸­æ–­
 133   1      
 134   1          ADC_ACON1 &= ~(ADC_VREF_SEL(0x7) |   // æ¸…é™¤é€‰æ‹©çš„å‚è€ƒç”µå‹
 135   1                         ADC_EXREF_SEL(0x01) | // å…³é—­å¤–éƒ¨å‚è€ƒç”µå‹
 136   1                         ADC_INREF_SEL(0x01)); // å…³é—­å†…éƒ¨å‚è€ƒç”µå‹
 137   1          ADC_ACON1 |= ADC_VREF_SEL(0x6) |     // é€‰æ‹©å†…éƒ¨å‚è€ƒç”µå‹VCCA ï¼ˆå›ºå®šä½¿ç”¨VCCAï¼Œä¸å»ä¿®æ”
             -¹ï¼‰
 138   1                       ADC_TEN_SEL(0x3);       // å…³é—­æµ‹è¯•ä¿¡å·
 139   1          ADC_ACON0 = ADC_CMP_EN(0x1) |        // æ‰“å¼€ADCä¸­çš„CMPä½¿èƒ½ä¿¡å·
 140   1                      ADC_BIAS_EN(0x1) |       // æ‰“å¼€ADCåç½®ç”µæµèƒ½ä½¿ä¿¡å·
 141   1                      ADC_BIAS_SEL(0x1);       // åç½®ç”µæµï¼š1x
 142   1      
 143   1          ADC_TRGS0 |= (0x07 << 4); // é€šé“ 0DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 1
 144   1          ADC_CHS0 |= (0x01 << 6);  // ä½¿èƒ½ é€šé“ 0DLY åŠŸèƒ½
 145   1      
 146   1          ADC_TRGS1 |= (0x07 << 4); // é…ç½®é€šé“ 1DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 
             -1
 147   1          ADC_CHS1 |= (0x01 << 6);  // ä½¿èƒ½é€šé“ 1DLY åŠŸèƒ½
 148   1      
 149   1          ADC_TRGS2 |= (0x07 << 4); // é…ç½®é€šé“ 2DLY çš„ ADC æ—¶é’Ÿä¸ªæ•°é€‰æ‹©ï¼Œé…ç½®ä¸º 4n+1ï¼Œ4 * 29 + 
             -1
 150   1          ADC_CHS2 |= (0x01 << 6);  // ä½¿èƒ½é€šé“ 2DLY åŠŸèƒ½
 151   1      
 152   1          ADC_CFG1 |= (0x0F << 3) | // ADCæ—¶é’Ÿåˆ†é¢‘ä¸º16åˆ†é¢‘ï¼Œä¸ºç³»ç»Ÿæ—¶é’Ÿ/16
 153   1                      (0x01 << 2) | // ADC2 é€šé“ä¸­æ–­ä½¿èƒ½
 154   1                      (0x01 << 1) | // ADC1 é€šé“ä¸­æ–­ä½¿èƒ½
 155   1                      (0x01 << 0);  // ADC0 é€šé“ä¸­æ–­ä½¿èƒ½
 156   1          ADC_CFG2 = 0xFF;          // é€šé“0 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
 157   1          ADC_CFG3 = 0xFF;          // é€šé“1 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
 158   1          ADC_CFG4 = 0xFF;          // é€šé“2 é‡‡æ ·æ—¶é—´é…ç½®ä¸º256ä¸ªé‡‡æ ·æ—¶é’Ÿå‘¨æœŸ
 159   1      
 160   1          adc0_channel_sel();
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 4   

 161   1          adc1_channel_sel();
 162   1          adc2_channel_sel(ADC_SEL_PIN_NONE);
 163   1      
 164   1          ADC_CFG0 |= ADC_CHAN0_EN(0x01) |
 165   1                      ADC_CHAN1_EN(0x01) |
 166   1                      ADC_CHAN2_EN(0x01) |
 167   1                      ADC_EN(0x01); // ä½¿èƒ½adc
 168   1      
 169   1          delay_ms(1); // ç­‰å¾…adcç¨³å®š
 170   1      }
 171          
 172          // é…ç½®adc0ï¼Œadc0åªé€‰æ‹©æ£€æµ‹å‘åŠ¨æœºçš„é€šé“
 173          void adc0_channel_sel(void)
 174          {
 175   1          ADC_CHS0 &= ~(ADC_EXT_SEL(0x01));  // é€‰æ‹©å¤–éƒ¨é€šé“
 176   1          ADC_CHS0 &= ~(0x1F << 0);          // æ¸…ç©º adc0 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
 177   1          ADC_CHS0 |= ADC_ANALOG_CHAN(0x17); // adc0 é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x17--P27ï¼‰
 178   1      }
 179          
 180          // é…ç½®adc1 adc1åªæ£€æµ‹æ—‹é’®è°ƒå…‰çš„é€šé“
 181          void adc1_channel_sel(void)
 182          {
 183   1          ADC_CHS1 &= ~(ADC_EXT_SEL(0x01)); // é€‰æ‹©å¤–éƒ¨é€šé“
 184   1          ADC_CHS1 &= ~(0x1F << 0);         // æ¸…ç©º adc1 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
 185   1          ADC_CHS1 = ADC_ANALOG_CHAN(0x19); // é€‰åˆ™å¼•è„šå¯¹åº”çš„é€šé“ï¼ˆ0x19--P31ï¼‰
 186   1      }
 187          
 188          /**
 189           * @brief é…ç½®adc2 adc2 è¦æ£€æµ‹æ¸©åº¦ã€é£æ‰‡çŠ¶æ€
 190           *      åˆ‡æ¢å®Œæˆåï¼Œä¸èƒ½é©¬ä¸Šä½¿ç”¨ï¼Œè¦ç­‰adcç¨³å®š
 191           */
 192          void adc2_channel_sel(u8 adc_sel_pin)
 193          {
 194   1          static u8 last_adc_sel = 0;
 195   1          if (last_adc_sel == adc_sel_pin)
 196   1          {
 197   2              // å¦‚æœå½“å‰é‡‡é›†adcçš„å¼•è„šå°±æ˜¯è¦é…ç½®çš„adcå¼•è„šï¼Œä¸ç”¨å†ç»§ç»­é…ç½®ï¼Œç›´æ¥é€€å‡
             -º
 198   2              return;
 199   2          }
 200   1      
 201   1          last_adc_sel = adc_sel_pin;
 202   1      
 203   1          ADC_CHS2 &= ~(ADC_EXT_SEL(0x01)); // é€‰æ‹©å¤–éƒ¨é€šé“
 204   1          ADC_CHS2 &= ~(0x1F << 0);         // æ¸…ç©º adc2 é€‰æ‹©çš„æ¨¡æ‹Ÿé€šé“
 205   1      
 206   1          switch (adc_sel_pin)
 207   1          {
 208   2          case ADC_SEL_PIN_GET_TEMP:
 209   2          {
 210   3              ADC_CHS2 |= 0x18 << 0;
 211   3          }
 212   2          break;
 213   2          case ADC_SEL_PIN_FAN_DETECT:
 214   2          {
 215   3              ADC_CHS2 |= 0x0B << 0;
 216   3          }
 217   2          break;
 218   2      
 219   2          default:
 220   2              break;
 221   2          }
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 5   

 222   1      }
 223          
 224          // adcå•æ¬¡é‡‡é›†+è½¬æ¢ï¼ˆæ²¡æœ‰æ»¤æ³¢ï¼‰
 225          // u16 adc_get_val_single(void)
 226          // {
 227          //     u16 adc_val = 0;
 228          //     ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 229          //     while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 230          //         ;                                            // ç­‰å¾…è½¬æ¢å®Œæˆ
 231          //     adc_val = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å–channel0çš„å€¼
 232          //     ADC_STA = ADC_CHAN0_DONE(0x1);                   // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 233          //     return adc_val;
 234          // }
 235          
 236          // è·å–ä¸€æ¬¡adcé‡‡é›†+æ»¤æ³¢åçš„å€¼
 237          // u16 adc_get_val(void)
 238          // {
 239          //     u8 i = 0; // adcé‡‡é›†æ¬¡æ•°çš„è®¡æ•°
 240          //     volatile u16 g_temp_value = 0;
 241          //     volatile u32 g_tmpbuff = 0;
 242          //     volatile u16 g_adcmax = 0;
 243          //     volatile u16 g_adcmin = 0xFFFF;
 244          
 245          //     // é‡‡é›†20æ¬¡ï¼Œå»æ‰å‰ä¸¤æ¬¡é‡‡æ ·ï¼Œå†å»æ‰ä¸€ä¸ªæœ€å¤§å€¼å’Œä¸€ä¸ªæœ€å°å€¼ï¼Œå†å–å¹³å‡å
             -€¼
 246          //     for (i = 0; i < 20; i++)
 247          //     {
 248          //         ADC_CFG0 |= ADC_CHAN0_TRG(0x1); // è§¦å‘ADC0è½¬æ¢
 249          //         while (!(ADC_STA & ADC_CHAN0_DONE(0x1)))
 250          //             ;                                                 // ç­‰å¾…è½¬æ¢å®Œæˆ
 251          //         g_temp_value = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4); // è¯»å– channel0 çš„å€¼
 252          //         ADC_STA = ADC_CHAN0_DONE(0x1);                        // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 253          
 254          //         if (i < 2)
 255          //             continue; // ä¸¢å¼ƒå‰ä¸¤æ¬¡é‡‡æ ·çš„
 256          //         if (g_temp_value > g_adcmax)
 257          //             g_adcmax = g_temp_value; // æœ€å¤§
 258          //         if (g_temp_value < g_adcmin)
 259          //             g_adcmin = g_temp_value; // æœ€å°
 260          
 261          //         g_tmpbuff += g_temp_value;
 262          //     }
 263          
 264          //     g_tmpbuff -= g_adcmax;           // å»æ‰ä¸€ä¸ªæœ€å¤§
 265          //     g_tmpbuff -= g_adcmin;           // å»æ‰ä¸€ä¸ªæœ€å°
 266          //     g_temp_value = (g_tmpbuff >> 4); // é™¤ä»¥16ï¼Œå–å¹³å‡å€¼
 267          
 268          //     return g_temp_value;
 269          // }
 270          
 271          // ä»å¼•è„šä¸Šé‡‡é›†æ»¤æ³¢åçš„ç”µå‹å€¼,å‡½æ•°å†…éƒ¨ä¼šå°†é‡‡é›†åˆ°çš„adè½¬æ¢æˆå¯¹åº”çš„ç”µå‹å€¼
 272          u32 get_voltage_from_pin(void)
 273          {  
 274   1          return (u32)adc_val_from_temp * 12 / 10;
 275   1      }
 276          
 277          // æ¸©åº¦æ£€æµ‹åŠŸèƒ½
 278          void temperature_scan(void)
 279          {
 280   1          volatile u32 voltage = 0; // å­˜æ”¾adcé‡‡é›†åˆ°çš„ç”µå‹ï¼Œå•ä½ï¼šmV
 281   1      
 282   1          // å¦‚æœå·²ç»è¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5minï¼Œä¸ç”¨å†æ£€æµ‹8è„šçš„ç”µå‹ï¼Œç­‰å¾…ç”¨æˆ·æ’æŸ¥åŸå›
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 6   

             - ï¼Œå†é‡å¯ï¼ˆé‡æ–°ä¸Šç”µï¼‰
 283   1          if (TEMP_75_5_MIN == temp_status)
 284   1          {
 285   2              return;
 286   2          }
 287   1      
 288   1          {
 289   2              // è°ƒç”¨è¯¥å‡½æ•°ä¸€å®šæ¬¡æ•°ä¹‹åï¼Œæ‰è¿›è¡Œæ¸©åº¦æ£€æµ‹ï¼Œç¼©çŸ­ä¸»å¾ªç¯çš„æ‰§è¡Œå‘¨æœŸ
 290   2              static volatile u8 cnt = 0;
 291   2              cnt++;
 292   2              if (cnt < 100)
 293   2              {
 294   3                  return;
 295   3              }
 296   2      
 297   2              cnt = 0;
 298   2          }
 299   1       
 300   1          voltage = get_voltage_from_pin(); // å¾—åˆ°çƒ­æ•ç”µé˜»ä¸Šçš„ç”µå‹
 301   1       
 302   1      
 303   1      #if USE_MY_DEBUG
                  // printf("PIN-8 voltage: %lu mV\n", voltage);
              #endif // USE_MY_DEBUG
 306   1      
 307   1          // å¦‚æœä¹‹å‰çš„æ¸©åº¦ä¸ºæ­£å¸¸ï¼Œæ£€æµ‹æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦ï¼ˆÂ±5æ‘„æ°åº¦ï¼‰
 308   1          // if (TEMP_NORMAL == temp_status && voltage < VOLTAGE_TEMP_75)
 309   1          if (TEMP_NORMAL == temp_status)
 310   1          {
 311   2              // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å
             -€¼ï¼‰
 312   2              static volatile u8 cnt = 0;
 313   2              if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è¦å°
             -äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 314   2              {
 315   3                  cnt++;
 316   3              }
 317   2              else
 318   2              {
 319   3                  cnt = 0;
 320   3              }
 321   2      
 322   2              if (cnt >= 10)
 323   2              {
 324   3                  cnt = 0; 
 325   3                  temp_status = TEMP_75; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦
 326   3              }
 327   2              else
 328   2              {
 329   3                  temp_status = TEMP_NORMAL;
 330   3              }
 331   2      
 332   2              return; // å‡½æ•°è¿”å›ï¼Œè®©è°ƒèŠ‚å ç©ºæ¯”çš„å‡½æ•°å…ˆè¿›è¡Œè°ƒèŠ‚
 333   2          }
 334   1          else if (TEMP_75 == temp_status)
 335   1          {
 336   2              // å¦‚æœä¹‹å‰çš„æ¸©åº¦è¶…è¿‡75æ‘„æ°åº¦
 337   2              static bit tmr1_is_open = 0;
 338   2      
 339   2              if (0 == tmr1_is_open)
 340   2              {
 341   3                  tmr1_is_open = 1;
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 7   

 342   3                  tmr1_cnt = 0;
 343   3                  tmr1_enable(); // æ‰“å¼€å®šæ—¶å™¨ï¼Œå¼€å§‹è®°å½•æ˜¯å¦å¤§äº75æ‘„æ°åº¦ä¸”è¶…è¿‡ä¸€å®šæ—¶é—´
 344   3              }
 345   2      
 346   2              // å¦‚æœè¶…è¿‡75æ‘„æ°åº¦å¹¶ä¸”è¿‡äº†5minï¼Œå†æ£€æµ‹æ¸©åº¦æ˜¯å¦è¶…è¿‡75æ‘„æ°åº¦
 347   2              if (tmr1_cnt >= (u32)TMR1_CNT_5_MINUTES)
 348   2              {
 349   3                  static volatile u8 cnt = 0;
 350   3      
 351   3                  if (voltage < VOLTAGE_TEMP_75) // å¦‚æœæ£€æµ‹åˆ°æ¸©åº¦å¤§äº75æ‘„æ°åº¦ï¼ˆæµ‹å¾—çš„ç”µå‹å€¼è
             -¦å°äº75æ‘„æ°åº¦å¯¹åº”çš„ç”µå‹å€¼ï¼‰
 352   3                  {
 353   4                      cnt++;
 354   4                  }
 355   3                  else
 356   3                  {
 357   4                      cnt = 0;
 358   4                  }
 359   3      
 360   3                  if (cnt >= 10)
 361   3                  {
 362   4                      cnt = 0;
 363   4                      temp_status = TEMP_75_5_MIN; // çŠ¶æ€æ ‡å¿—è®¾ç½®ä¸ºè¶…è¿‡75æ‘„æ°åº¦ä¸”è¶…è¿‡5min
 364   4                      tmr1_disable();              // å…³é—­å®šæ—¶å™¨
 365   4                      tmr1_cnt = 0;                // æ¸…ç©ºæ—¶é—´è®¡æ•°å€¼
 366   4                      tmr1_is_open = 0;
 367   4                  }
 368   3                  else
 369   3                  {
 370   4                      temp_status = TEMP_75;
 371   4                  }
 372   3      
 373   3                  return;
 374   3              }
 375   2          }
 376   1      }
 377          
 378          // æ ¹æ®æ¸©åº¦ï¼ˆç”µå‹å€¼æ‰«æï¼‰æˆ–9è„šçš„çŠ¶æ€æ¥è®¾å®šå ç©ºæ¯”
 379          void set_duty(void)
 380          {
 381   1          // å¦‚æœæ¸©åº¦æ­£å¸¸ï¼Œæ ¹æ®9è„šçš„çŠ¶æ€æ¥è°ƒèŠ‚PWMå ç©ºæ¯”
 382   1          if (TEMP_NORMAL == temp_status)
 383   1          {
 384   2              if (flag_is_time_to_check_engine)
 385   2              {
 386   3                  flag_is_time_to_check_engine = 0;
 387   3                  according_pin9_to_adjust_pwm();
 388   3              }
 389   2          }
 390   1          else if (TEMP_75 == temp_status)
 391   1          {
 392   2              limited_pwm_duty_due_to_temp = PWM_DUTY_50_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -50%
 393   2          }
 394   1          else if (TEMP_75_5_MIN == temp_status)
 395   1          {
 396   2              limited_pwm_duty_due_to_temp = PWM_DUTY_25_PERCENT; // å°†pwmå ç©ºæ¯”é™åˆ¶åˆ°æœ€å¤§å ç©ºæ¯”çš„ 
             -25%
 397   2          }
 398   1      }
 399          
 400          // volatile u16 adc_val_pin_9_filter_count = 0;
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 8   

 401          // u16 adc_val_pin_9_temp;
 402          // æ›´æ–°9è„šé‡‡é›†çš„adå€¼
 403          // void adc_update_pin_9_adc_val(void)
 404          // {
 405          //     adc_sel_pin(ADC_SEL_PIN_GET_VOL);
 406          //     adc_val_pin_9 = adc_get_val();
 407          
 408          //     // adc_val_pin_9 = 1000; // æµ‹è¯•æ—¶ä½¿ç”¨
 409          
 410          // #if USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 411          //     // printf("adc_val_pin_9 %u\n", adc_val_pin_9);
 412          
 413          //     // printf(",a=%u,", adc_val_pin_9);
 414          // #endif // USE_MY_DEBUG // æ‰“å°ä»9è„šé‡‡é›†åˆ°çš„adå€¼
 415          // }
 416          
 417          void fan_scan(void)
 418          {
 419   1          u16 adc_val = adc_val_from_fan; // adc_val_from_fan ç”±adcä¸­æ–­è§¦å‘
 420   1      
 421   1          /*
 422   1              1è„šç”µå‹ä½äº4.3Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º25%å ç©ºæ¯”ï¼Œ
 423   1              1è„šç”µå‹é«˜äº4.5Væ—¶ï¼Œ14ï¼Œ15è„šè¾“å‡º100%å ç©ºæ¯”
 424   1          */
 425   1          if (FAN_STATUS_NORMAL == cur_fan_status)
 426   1          {
 427   2              if (adc_val <= ADC_VAL_WHEN_FAN_ERR)
 428   2              {
 429   3                  flag_tim_scan_fan_is_err = 1; // è¡¨ç¤ºé£æ‰‡å¼‚å¸¸ï¼Œè®©å®šæ—¶å™¨ç´¯è®¡æ—¶é—´
 430   3              }
 431   2              else
 432   2              {
 433   3                  // é£æ‰‡æ­£å¸¸æ—¶ï¼Œåªè¦æœ‰ä¸€æ¬¡adå€¼ä¸æ»¡è¶³å¼‚å¸¸çš„æ¡ä»¶ï¼Œä¾¿è®¤ä¸ºå®ƒæ˜¯æ­£å¸¸å·¥ä½
             -œ
 434   3                  flag_tim_scan_fan_is_err = 0;
 435   3              }
 436   2      
 437   2              // é£æ‰‡æ­£å¸¸å·¥ä½œï¼Œpwmæ­£å¸¸è¾“å‡º
 438   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_100_PERCENT;
 439   2          }
 440   1          else // FAN_STATUS_ERROR == cur_fan_status
 441   1          {
 442   2              // é£æ‰‡å¼‚å¸¸æ—¶ï¼Œæ£€æµ‹åˆ°çš„adå€¼è¦ä¸ã€é£æ‰‡å¼‚å¸¸æ—¶å¯¹åº”çš„adå€¼ã€‘ç›¸éš”ä¸€ä¸ªæ­»åŒºï
             -¼Œæ‰è®¤ä¸ºé£æ‰‡æ¢å¤æ­£å¸¸
 443   2              if (adc_val >= ADC_VAL_WHEN_FAN_NORMAL)
 444   2              {
 445   3                  flag_tim_scan_fan_is_err = 0; // è¡¨ç¤ºé£æ‰‡æ­£å¸¸
 446   3              }
 447   2      
 448   2              // é£æ‰‡å·¥ä½œå¼‚å¸¸ï¼Œé™åˆ¶pwmè¾“å‡ºï¼Œå ç©ºæ¯”ä¸è¶…è¿‡25%
 449   2              limited_pwm_duty_due_to_fan_err = PWM_DUTY_25_PERCENT;
 450   2          }
 451   1      }
 452          
 453          void ADC_IRQHandler(void) interrupt ADC_IRQn
 454          {
 455   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 456   1          __IRQnIPnPush(ADC_IRQn);
 457   1      
 458   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 459   1      
 460   1          if (ADC_STA & ADC_CHAN0_DONE(0x01))
C51 COMPILER V9.60.7.0   ADC                                                               11/08/2025 16:53:10 PAGE 9   

 461   1          {
 462   2              ADC_STA |= ADC_CHAN0_DONE(0x01); // æ¸…é™¤ADC0è½¬æ¢å®Œæˆæ ‡å¿—ä½
 463   2              adc_val_from_engine = (ADC_DATAH0 << 4) | (ADC_DATAL0 >> 4);
 464   2          }
 465   1      
 466   1          if (ADC_STA & ADC_CHAN1_DONE(0x01))
 467   1          {
 468   2              ADC_STA |= ADC_CHAN1_DONE(0x01); // æ¸…é™¤ADC1è½¬æ¢å®Œæˆæ ‡å¿—ä½
 469   2              adc_val_from_knob = (ADC_DATAH1 << 4) | (ADC_DATAL1 >> 4);
 470   2          }
 471   1      
 472   1          if (ADC_STA & ADC_CHAN2_DONE(0x01))
 473   1          {
 474   2              ADC_STA |= ADC_CHAN2_DONE(0x01); // æ¸…é™¤ADC2è½¬æ¢å®Œæˆæ ‡å¿—ä½
 475   2      
 476   2              if (ADC2_STATUS_SEL_GET_TEMP == cur_adc2_status)
 477   2              {
 478   3                  // å¦‚æœå½“å‰å¯¹åº”çš„æ˜¯è·å–æ¸©åº¦çš„adcé€šé“
 479   3                  adc_val_from_temp = (ADC_DATAH2 << 4) | (ADC_DATAL2 >> 4);
 480   3              }
 481   2              else if (ADC2_STATUS_SEL_FAN_DETECT == cur_adc2_status)
 482   2              {
 483   3                  // å¦‚æœå½“å‰å¯¹åº”çš„æ˜¯æ£€æµ‹é£æ‰‡çš„adcé€šé“
 484   3                  adc_val_from_fan = (ADC_DATAH2 << 4) | (ADC_DATAL2 >> 4);
 485   3              }
 486   2          }
 487   1      
 488   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 489   1          __IRQnIPnPop(ADC_IRQn);
 490   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    679    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     15       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
